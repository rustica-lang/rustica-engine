From 54cb509104b1add72ee02eac534569c6d64e1d25 Mon Sep 17 00:00:00 2001
From: Xenia Lu <xenia.lyy@gmail.com>
Date: Wed, 22 Jan 2025 18:46:35 +0800
Subject: [PATCH 5/5] Support custom global resolver

---
 core/iwasm/aot/aot_loader.c          | 18 +++++++
 core/iwasm/common/wasm_native.c      | 73 ++++++++++++++++++++++++++++
 core/iwasm/common/wasm_native.h      | 24 +++++++++
 core/iwasm/interpreter/wasm.h        |  9 ++++
 core/iwasm/interpreter/wasm_loader.c | 23 ++++++++-
 5 files changed, 146 insertions(+), 1 deletion(-)

diff --git a/core/iwasm/aot/aot_loader.c b/core/iwasm/aot/aot_loader.c
index 95984387..a8689580 100644
--- a/core/iwasm/aot/aot_loader.c
+++ b/core/iwasm/aot/aot_loader.c
@@ -2289,6 +2289,24 @@ load_import_globals(const uint8 **p_buf, const uint8 *buf_end,
         import_globals[i].is_linked = false;
 #endif
 
+        /* Call custom globals resolver */
+        if (!import_globals[i].is_linked) {
+            WASMValue *linked_data = wasm_resolve_global(
+                import_globals[i].module_name, import_globals[i].global_name,
+#if WASM_SUPPORT_NUL_IN_STRING != 0
+                import_globals[i].global_name_len,
+#endif
+#if WASM_ENABLE_GC != 0
+                NULL,
+#endif
+                import_globals[i].type.val_type,
+                import_globals[i].type.is_mutable);
+            if (linked_data) {
+                import_globals[i].global_data_linked = *linked_data;
+                import_globals[i].is_linked = true;
+            }
+        }
+
         import_globals[i].size =
             wasm_value_type_size(import_globals[i].type.val_type);
         import_globals[i].data_offset = data_offset;
diff --git a/core/iwasm/common/wasm_native.c b/core/iwasm/common/wasm_native.c
index 060bb2c3..d374c977 100644
--- a/core/iwasm/common/wasm_native.c
+++ b/core/iwasm/common/wasm_native.c
@@ -20,6 +20,7 @@
 #endif
 
 static NativeSymbolsList g_native_symbols_list = NULL;
+static GlobalResolverList g_global_resolvers_list = NULL;
 
 #if WASM_ENABLE_LIBC_WASI != 0
 static void *g_wasi_context_key;
@@ -324,6 +325,78 @@ wasm_native_unregister_natives(const char *module_name,
     return false;
 }
 
+WASMValue *
+wasm_resolve_global(const char *module_name, const char *global_name,
+#if WASM_SUPPORT_NUL_IN_STRING != 0
+                    uint32 global_name_len,
+#endif
+#if WASM_ENABLE_GC != 0
+                    WASMRefType *ref_type,
+#endif
+                    uint8 val_type, uint8 is_mutable)
+{
+    GlobalResolverNode *node, *node_next;
+    WASMValue *rv = NULL;
+
+    node = g_global_resolvers_list;
+    while (node) {
+        node_next = node->next;
+        if (!strcmp(node->module_name, module_name)) {
+            if ((rv = node->resolver(global_name,
+#if WASM_SUPPORT_NUL_IN_STRING != 0
+                                     global_name_len,
+#endif
+#if WASM_ENABLE_GC != 0
+                                     ref_type,
+#endif
+                                     val_type, is_mutable)))
+                break;
+        }
+        node = node_next;
+    }
+
+    return rv;
+}
+
+bool
+wasm_register_global_resolver(const char *module_name,
+                              wasm_global_resolver_t resolver)
+{
+    GlobalResolverNode *node;
+
+    if (!(node = wasm_runtime_malloc(sizeof(GlobalResolverNode))))
+        return false;
+
+    node->module_name = module_name;
+    node->resolver = resolver;
+
+    node->next = g_global_resolvers_list;
+    g_global_resolvers_list = node;
+
+    return true;
+}
+
+bool
+wasm_unregister_global_resolver(const char *module_name,
+                                wasm_global_resolver_t resolver)
+{
+
+    GlobalResolverNode **prevp;
+    GlobalResolverNode *node;
+
+    prevp = &g_global_resolvers_list;
+    while ((node = *prevp) != NULL) {
+        if (node->resolver == resolver
+            && !strcmp(node->module_name, module_name)) {
+            *prevp = node->next;
+            wasm_runtime_free(node);
+            return true;
+        }
+        prevp = &node->next;
+    }
+    return false;
+}
+
 #if WASM_ENABLE_MODULE_INST_CONTEXT != 0
 static uint32
 context_key_to_idx(void *key)
diff --git a/core/iwasm/common/wasm_native.h b/core/iwasm/common/wasm_native.h
index 9a6afee1..3af48b50 100644
--- a/core/iwasm/common/wasm_native.h
+++ b/core/iwasm/common/wasm_native.h
@@ -22,6 +22,12 @@ typedef struct NativeSymbolsNode {
     bool call_conv_raw;
 } NativeSymbolsNode, *NativeSymbolsList;
 
+typedef struct GlobalResolverNode {
+    struct GlobalResolverNode *next;
+    const char *module_name;
+    wasm_global_resolver_t resolver;
+} GlobalResolverNode, *GlobalResolverList;
+
 /**
  * Lookup global variable of a given import global
  * from libc builtin globals
@@ -69,6 +75,24 @@ bool
 wasm_native_unregister_natives(const char *module_name,
                                NativeSymbol *native_symbols);
 
+WASMValue *
+wasm_resolve_global(const char *module_name, const char *global_name,
+#if WASM_SUPPORT_NUL_IN_STRING != 0
+                    uint32 global_name_len,
+#endif
+#if WASM_ENABLE_GC != 0
+                    WASMRefType *ref_type,
+#endif
+                    uint8 val_type, uint8 is_mutable);
+
+bool
+wasm_register_global_resolver(const char *module_name,
+                              wasm_global_resolver_t resolver);
+
+bool
+wasm_unregister_global_resolver(const char *module_name,
+                                wasm_global_resolver_t resolver);
+
 #if WASM_ENABLE_MODULE_INST_CONTEXT != 0
 struct WASMModuleInstanceCommon;
 
diff --git a/core/iwasm/interpreter/wasm.h b/core/iwasm/interpreter/wasm.h
index 9ffb9cd6..ef88e00b 100644
--- a/core/iwasm/interpreter/wasm.h
+++ b/core/iwasm/interpreter/wasm.h
@@ -1172,6 +1172,15 @@ typedef struct WASMBranchBlock {
 #endif
 } WASMBranchBlock;
 
+typedef WASMValue *(*wasm_global_resolver_t)(const char *name,
+#if WASM_SUPPORT_NUL_IN_STRING != 0
+                                             uint32 name_len,
+#endif
+#if WASM_ENABLE_GC != 0
+                                             WASMRefType *ref_type,
+#endif
+                                             uint8 val_type, uint8 is_mutable);
+
 /**
  * Align an unsigned value on a alignment boundary.
  *
diff --git a/core/iwasm/interpreter/wasm_loader.c b/core/iwasm/interpreter/wasm_loader.c
index 4b8ad2d9..cbb7310a 100644
--- a/core/iwasm/interpreter/wasm_loader.c
+++ b/core/iwasm/interpreter/wasm_loader.c
@@ -3308,6 +3308,26 @@ load_global_import(const uint8 **p_buf, const uint8 *buf_end,
         global->is_linked = true;
     }
 #endif
+
+    /* Call custom globals resolver */
+    if (!global->is_linked) {
+        WASMValue *linked_data =
+            wasm_resolve_global(sub_module_name, global_name,
+#if WASM_SUPPORT_NUL_IN_STRING != 0
+                                global_name_len,
+#endif
+#if WASM_ENABLE_GC != 0
+                                &ref_type,
+#endif
+                                declare_type, declare_mutable);
+        if (linked_data) {
+            global->type.val_type = declare_type;
+            global->type.is_mutable = declare_mutable;
+            global->global_data_linked = *linked_data;
+            global->is_linked = true;
+        }
+    }
+
 #if WASM_ENABLE_MULTI_MODULE != 0
     if (!global->is_linked
         && !wasm_runtime_is_built_in_module(sub_module_name)) {
@@ -4361,7 +4381,8 @@ load_global_section(const uint8 *buf, const uint8 *buf_end, WASMModule *module,
                             ->globals[global_idx - module->import_global_count]
                             .ref_type;
                 }
-                if (!wasm_reftype_is_subtype_of(
+                if (global->ref_type
+                    && !wasm_reftype_is_subtype_of(
                         global_type, global_ref_type, global->type.val_type,
                         global->ref_type, module->types, module->type_count)) {
                     set_error_buf(error_buf, error_buf_size, "type mismatch");
-- 
2.51.0

